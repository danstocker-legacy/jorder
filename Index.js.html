<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Index.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Index.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/*global dessert, troop, sntls, jorder */
troop.postpone(jorder, 'Index', function () {
    "use strict";

    /**
     * Instantiates class.
     * @name jorder.Index.create
     * @function
     * @param {string[]} fieldNames Field names
     * @param {string} [signatureType='string'] Signature type, see SIGNATURE_TYPES.
     * @param {boolean} [isCaseInsensitive=false] Whether signature is case insensitive.
     * @return {jorder.Index}
     */

    /**
     * Table index. Keeps track of single of composite fields, enables binary search in tables.
     * @class jorder.Index
     * @extends troop.Base
     */
    jorder.Index = troop.Base.extend()
        .addPrivateMethods(/** @lends jorder.Index# */{
            /**
             * Retrieves unique row IDs for non-unique list of keys (row signatures).
             * @param {sntls.Hash} keysAsHash
             * @returns {string[]}
             * @private
             */
            _getUniqueRowIdsForKeys: function (keysAsHash) {
                return keysAsHash
                    // obtaining row IDs from lookup
                    .toStringDictionary()
                    .combineWith(this.rowIdLookup)
                    // collapsing unique row IDs
                    .getUniqueValues();
            }
        })
        .addMethods(/** @lends jorder.Index# */{
            /**
             * @param {string[]} fieldNames Field names
             * @param {string} [signatureType='string'] Signature type, see SIGNATURE_TYPES.
             * @param {boolean} [isCaseInsensitive=false] Whether signature is case insensitive.
             * @ignore
             */
            init: function (fieldNames, signatureType, isCaseInsensitive) {
                /**
                 * Row signature associated with index.
                 * Provides validation and index key generation.
                 * @type {jorder.RowSignature}
                 */
                this.rowSignature = jorder.RowSignature.create(fieldNames, signatureType, isCaseInsensitive);

                /**
                 * Holds index key -> row ID associations.
                 * One index key may reference more than one row IDs.
                 * @type {sntls.StringDictionary}
                 */
                this.rowIdLookup = sntls.StringDictionary.create();

                /**
                 * Holds index keys in ascending order. (With multiplicity)
                 * @type {sntls.OrderedStringList}
                 */
                this.sortedKeys = sntls.OrderedStringList.create();
            },

            /**
             * Adds single row to index.
             * @param {object} row Table row
             * @param {string|number} rowId Row ID: original index of row in table
             * @return {jorder.Index}
             */
            addRow: function (row, rowId) {
                // calculating index keys based on row
                var keys = this.rowSignature.getKeysForRow(row);

                // adding key / rowId pairs to lookup index
                this.rowIdLookup.addItems(keys, rowId);

                // adding keys to ordered index (w/ multiplicity)
                this.sortedKeys.addItems(keys);

                return this;
            },

            /**
             * Removes single row from index.
             * @param {object} row Table row
             * @param {string} rowId Row ID: original index of row in table
             * @return {jorder.Index}
             */
            removeRow: function (row, rowId) {
                // calculating index keys based on row
                var keys = this.rowSignature.getKeysForRow(row);

                // removing key / rowId pairs from lookup index
                this.rowIdLookup.removeItems(keys, rowId);

                // removing keys from ordered index (w/ multiplicity)
                this.sortedKeys.removeItems(keys);

                return this;
            },

            /**
             * Clears index buffers.
             * @return {jorder.Index}
             */
            clearBuffers: function () {
                // clearing lookup buffers
                this.rowIdLookup.clear();
                this.sortedKeys.clear();

                return this;
            },

            /**
             * Retrieves a row ID (or row IDs if index is not unique) associated with the specified offset in the index.
             * Supposed to be used on unique indexes, where position in the index is unambiguous.
             * @param {number} offset
             * @returns {number|number[]}
             */
            getRowIdAt: function (offset) {
                return this.sortedKeys.items.slice(offset, offset + 1)
                    .toStringDictionary()
                    .combineWith(this.rowIdLookup)
                    .getFirstValue();
            },

            /**
             * Retrieves a list of row IDs that are associated with the index entries between the specified positions,
             * wrapped in a hash. Result may contain array items in case the index is not unique.
             * Supposed to be used on unique indexes, where position in the index is unambiguous.
             * @param {number} startOffset
             * @param {number} endOffset
             * @returns {sntls.Dictionary}
             */
            getRowIdsBetweenAsHash: function (startOffset, endOffset) {
                return this.sortedKeys.items.slice(startOffset, endOffset)
                    .toStringDictionary()
                    .combineWith(this.rowIdLookup);
            },

            /**
             * Retrieves a list of row ids that are associated with the index entries between the specified positions,
             * wrapped in a hash.
             * @param {number} startOffset
             * @param {number} endOffset
             * @returns {number[]}
             */
            getRowIdsBetween: function (startOffset, endOffset) {
                return this.getRowIdsBetweenAsHash(startOffset, endOffset).items;
            },

            /**
             * Retrieves a list of row ids associated with the specified keys.
             * @param {string[]|number[]|string|number} keys Index keys to be looked up, expected to be
             * in correct case (ie. lowercase when index is case insensitive).
             * @return {string[]}
             */
            getRowIdsForKeys: function (keys) {
                if (!(keys instanceof Array)) {
                    keys = [keys];
                }

                return sntls.StringDictionary.create(keys)
                    // selecting row IDs for specified keys
                    .combineWith(this.rowIdLookup)
                    // collapsing unique row IDs
                    .getUniqueValues();
            },

            /**
             * Retrieves a list of row ids associated with the specified keys, wrapped in a hash.
             * @param {string[]|number[]|string|number} keys
             * @return {sntls.Hash}
             */
            getRowIdsForKeysAsHash: function (keys) {
                return sntls.Hash.create(this.getRowIdsForKeys(keys));
            },

            /**
             * Retrieves a list of unique row IDs matching index values
             * that fall between the specified bounds.
             * @param {string|number} startValue Lower index bound
             * @param {string|number} endValue Upper index bound
             * @param {number} [offset=0] Number of index entries to skip at start.
             * @param {number} [limit=Infinity] Maximum number of index entries to fetch.
             * @return {string[]}
             */
            getRowIdsForKeyRange: function (startValue, endValue, offset, limit) {
                if (this.rowSignature.isCaseInsensitive) {
                    // preparing key bounds for case insensitivity
                    startValue = startValue.toLowerCase();
                    endValue = endValue.toLowerCase();
                }

                return this.sortedKeys.getRangeAsHash(startValue, endValue, offset, limit)
                    .passSelfTo(this._getUniqueRowIdsForKeys, this);
            },

            /**
             * Retrieves a list of unique row IDs matching index values
             * that fall between the specified bounds, wrapped in a hash.
             * @param {string|number} startValue Lower index bound
             * @param {string|number} endValue Upper index bound
             * @param {number} [offset=0] Number of index entries to skip at start.
             * @param {number} [limit=Infinity] Maximum number of index entries to fetch.
             * @returns {sntls.Hash}
             */
            getRowIdsForKeyRangeAsHash: function (startValue, endValue, offset, limit) {
                return sntls.Hash.create(this.getRowIdsForKeyRange(startValue, endValue, offset, limit));
            },

            /**
             * Retrieves a list of unique row IDs matching index values
             * that start with the specified prefix.
             * @param {string} prefix Key prefix to be matched.
             * @param {number} [offset=0] Number of index entries to skip at start.
             * @param {number} [limit=Infinity] Maximum number of index entries to fetch.
             * @returns {*}
             */
            getRowIdsForPrefix: function (prefix, offset, limit) {
                if (this.rowSignature.isCaseInsensitive) {
                    // preparing key prefix for case insensitivity
                    prefix = prefix.toLowerCase();
                }

                return this.sortedKeys.getRangeByPrefixAsHash(prefix, false, offset, limit)
                    .passSelfTo(this._getUniqueRowIdsForKeys, this);
            },

            /**
             * Retrieves a list of unique row IDs matching index values
             * that start with the specified prefix, wrapped in a hash.
             * @param {string} prefix Key prefix to be matched.
             * @param {number} [offset=0] Number of index entries to skip at start.
             * @param {number} [limit=Infinity] Maximum number of index entries to fetch.
             * @returns {sntls.Hash}
             */
            getRowIdsForPrefixAsHash: function (prefix, offset, limit) {
                return sntls.Hash.create(this.getRowIdsForPrefix(prefix, offset, limit));
            }
        });
});

(function () {
    "use strict";

    dessert.addTypes(/** @lends dessert */{
        isIndex: function (expr) {
            return jorder.Index.isBaseOf(expr);
        },

        isIndexOptional: function (expr) {
            return typeof expr === 'undefined' ||
                   jorder.Index.isBaseOf(expr);
        }
    });
}());

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="jorder.Index.html">Index</a></li><li><a href="jorder.IndexCollection.html">IndexCollection</a></li><li><a href="jorder.IrregularNumber.html">IrregularNumber</a></li><li><a href="jorder.MultiArray.html">MultiArray</a></li><li><a href="jorder.RowSignature.html">RowSignature</a></li><li><a href="jorder.Table.html">Table</a></li></ul><h3>Namespaces</h3><ul><li><a href="jorder.html">jorder</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Fri Nov 21 2014 07:59:28 GMT-0000 (GMT)
</footer>

<script> prettyPrint(); </script>
</body>
</html>
